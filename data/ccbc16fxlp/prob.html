<!DOCTYPE html>
<meta charset="utf-8">
<title>浮想联翩</title>

<svg style="position:relative;left: 200px" width="960" height="600"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="links.json"></script>
<script src="nodes.json"></script>
<script>
var width = window.innerWidth - 300
var height = window.innerHeight + 1000
var testSolve = true;
var handAdjust = !testSolve;
var showDecomp = true;
var forceShowDecomp = false;
var PROGRESS_KEY = "ccbc16fxlp-progress";
//var randomStart = false || testSolve;
var username = "username";
var decompositionTypes = new Map([
	["⿰", "你披儒授双城鹅彩虹桃粉狄敦行物浮孔程红嫦祝樱件怖能蝶汉姆蜂顿纽断约欣波郎织提切律新秒托鸭徒致打诺邦滚拜引积仁语利冯腕腿刚相伦诚扰非统粽衬衫坡晚杨饼朗恨妃数枝娥秋拉礼枪模特短袖恤明时仗殖助调睡雅堤僧胳膊耶解妙泪满襟使捷性骡服驴险稻稣轴轼情则机裸羽佛的比私歌流浪救援诞说端幻狐冲诸教驰扬楼传功孩洲联林姓鲍体陕让弹牌记谋活汤优防膀戏潘始侠侣雕师欧北法漫懿湾珠刘隐地海婉动球形科技津维纳清斯神话孙悟郭张韶涵和沫神村肥杭掉德江绍论演峰塔阿呐喊拯牡河洛阳封腊"],
	["⿱", "森春柴亲分异黎琵琶丽占莎麦羿当卢卷桑梁智恐音名兔有肖命萧定霍前食熙节青易餐步元竞忍龟夜公贵恋梦帝雪笔鼎贞奇交觉冒黑圣字架杂岳露装关足雷华谷肯全盟最系育罗守艺学基督美宗著着台尔泰鱼秦皇令花臂兰英克爷苹典苏余多爱菲官零会蒙寺奥素黄安李杰若合葡萄金空笑兴盗星希"],
	["⿲", "树挪蝴湖浙浒游推微倒傲徽雄娜御"],
	["⿺", "翅迅迪达逍遥运道远辽速连"],
	["⿳", "亮章算蜜篮宫拿莫冥复慈意器芬莓京嵩葬葛赛黛慕蕊鲁荔"],
	["⿵", "威南间同周风"],
	["⿹", "式包可司武"],
	["⿶", "画"],
	["⿴", "国四团"],
	["⿷", "匹"],
	["⿸", "庄在屈质原魔历库后庸尼死厘康鹿唐居"],
]);

//baseLinks read from links.json
if (testSolve || handAdjust)
	baseLinks.push({ target: username, source: "你的名字。"})
if (handAdjust) {
	baseLinks.push(...[
		{ target: "白臂膊", source: "短袖子", type: "extraction"},
		{ target: "白臂膊", source: "全裸体", type: "extraction"},
		{ target: "生殖器", source: "全裸体", type: "extraction"},
		{ target: "生殖器", source: "性交", type: "extraction"},
		{ target: "杂交", source: "性交", type: "extraction"},
		{ target: "杂交", source: "私生子", type: "extraction"}]
	)
}

// filter out
baseLinks = baseLinks.filter(function (link) {
    return link.target != "电影" && link.type != "sound"
})

// only include nodes that appear at least twice in links
var baseNodeSetSeen = new Set([username])
var baseNodeSet = new Set()
for (let i = 0; i < baseLinks.length; i++) {
	if (baseNodeSetSeen.has(baseLinks[i].source))
		baseNodeSet.add(baseLinks[i].source);
	if (baseNodeSetSeen.has(baseLinks[i].target))
		baseNodeSet.add(baseLinks[i].target);
	baseNodeSetSeen.add(baseLinks[i].source);
	baseNodeSetSeen.add(baseLinks[i].target);
}
baseLinks = baseLinks.filter(function (link) {
    return baseNodeSet.has(link.target) && baseNodeSet.has(link.source)
})

var nodesJsonNodeSet = new Set()
for (let i = 0; i < baseNodes.length; i++) {
	nodesJsonNodeSet.add(baseNodes[i].id);
}

var visibleNodes = new Set()
// populate the actual data structure baseNodes, and randomize what's visible for testing
if (!testSolve) {
	if (!handAdjust) {
		baseNodes = []
	} else {
		baseNodes.push({"id":username, "x":430.20997429163566,"y":1072.9415429509277,"vy":0,"vx":0})
		nodesJsonNodeSet.add(username);
	}
	baseNodeSet.forEach((id) => {
		if (handAdjust) {
			if (!nodesJsonNodeSet.has(id)) {
				nodesJsonNodeSet.add(id);
				baseNodes.push(
					{id: id, x: width / 2, y: height / 2}
				);
			}
		} else {
			baseNodes.push({id: id});
		}
	});
} else {
	baseNodes.push({"id":username, "x":430.20997429163566,"y":1072.9415429509277,"vy":0,"vx":0})
}

var decompositionMap = new Map();
decompositionTypes.forEach((value, key) => {
	value.split("").forEach((c) => {
		decompositionMap.set(c, key);
	})
});
function decompose(c) {
  if (decompositionMap.has(c)) {
	return decompositionMap.get(c);
  } else {
    //console.log(c);
	//return "⬚";
	return c;
  }
}

function decomposeString(str) {
	let ret = "";
	str.split("").forEach((c) => {
		ret += decompose(c);
	});
	return ret;
}

// if a link connects to a node's decomposed is the same as the ID (i.e. all non-decomposable characters),
// then recursively add it to visible
function expandVisibleNodes() {
	var changed = true;
	do {
		changed = false;

		// now check links
		baseLinks.forEach((link) => {
			if (visibleNodes.has(link.source) && !visibleNodes.has(link.target)) {
				if (link.target == decomposeString(link.target)) {
					visibleNodes.add(link.target);
					changed = true;
				}
			} else if (visibleNodes.has(link.source.id) && !visibleNodes.has(link.target.id)) {
				if (link.target.id == decomposeString(link.target.id)) {
					visibleNodes.add(link.target.id);
					changed = true;
				}
			} else if (!visibleNodes.has(link.source) && visibleNodes.has(link.target)) {
				if (link.source == decomposeString(link.source)) {
					visibleNodes.add(link.source);
					changed = true;
				}
			} else if (!visibleNodes.has(link.source.id) && visibleNodes.has(link.target.id)) {
				if (link.source.id == decomposeString(link.source.id)) {
					visibleNodes.add(link.source.id);
					changed = true;
				}
			}
		});
	} while (changed);
}

function resetVisibleNodes() {
	visibleNodes = new Set()
	var changed = false;
	baseNodeSet.forEach((id) => {
		//if (!randomStart) {
			if (!testSolve || id == username)
				visibleNodes.add(id)
		/*} else if (Math.random() < 0.02) {
			visibleNodes.add(id)
			changed = true;
		}*/
	});
	expandVisibleNodes()
}
resetVisibleNodes()

function saveProgress() {
  try {
	const data = { visible: Array.from(visibleNodes) };
	localStorage.setItem(PROGRESS_KEY, JSON.stringify(data));
  } catch (e) {
	// ignore storage errors
  }
}

function loadProgress() {
  try {
	const raw = localStorage.getItem(PROGRESS_KEY);
	if (!raw)
	  return;
	const data = JSON.parse(raw);
	if (!data || !Array.isArray(data.visible))
	  return;
	data.visible.forEach((id) => {
	  if (baseNodeSet.has(id)) {
		visibleNodes.add(id);
	  }
	});
	expandVisibleNodes();
  } catch (e) {
	// ignore storage errors
  }
}

loadProgress()

var nodes = []
var links = []

function getNeighbors(node) {
  return baseLinks.reduce(function (neighbors, link) {
      if (link.target.id === node.id) {
        neighbors.push(link.source.id)
      } else if (link.source.id === node.id) {
        neighbors.push(link.target.id)
      }
      return neighbors
    },
    [node.id]
  )
}

function isNeighborLink(node, link) {
  return link.target.id === node.id || link.source.id === node.id
}

/*
function getNodeColor(node, neighbors) {
  if (Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1) {
    return node.level === 1 ? 'blue' : 'green'
  }

  return node.level === 1 ? 'red' : 'gray'
}*/


function getLinkColor(node, link) {
  return isNeighborLink(node, link) ? 'green' : '#E5E5E5'
}

/*
function getTextColor(node, neighbors) {
  return Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1 ? 'green' : 'black'
}*/

var answer = "明日歌的前五字"
function getTextColor(node) {
  for (let i = 0; i < baseLinks.length; i++) {
	if ((baseLinks[i].target == node && baseLinks[i].source.id == selectedId) || (baseLinks[i].source == node && baseLinks[i].target.id == selectedId)) {
		return "red"
	}
  }
  //console.log(node);
  if (node.id === "鲁迅")
	return "blue"
  if (testSolve)
	return "green"
  /*
  for (let i = 0; i < answer.length; i++) {
	if (node.id.includes(answer[i])) {
		return "red";
	}
  }*/
  return "green"
}

var svg = d3.select('svg')
svg.attr('width', width).attr('height', height)

var linkElements,
  nodeElements,
  textElements

// we use svg groups to logically group the elements together
var linkGroup = svg.append('g').attr('class', 'links')
var nodeGroup = svg.append('g').attr('class', 'nodes')
var textGroup = svg.append('g').attr('class', 'texts')

// we use this reference to select/deselect
// after clicking the same element twice
var selectedId

// simulation setup with all forces
var linkForce = d3
  .forceLink()
  .id(function (link) { return link.id })
  //.strength(function (link) { return link.strength })
  .strength(function (link) {
		return (handAdjust || testSolve) ? 0 : (link.type == "extraction" ? 0.2 : 0.8)
  })

var charge = d3.forceManyBody().strength(-150)
if (handAdjust || testSolve) {
	charge = null
}

var simulation = d3
  .forceSimulation()
  .force('link', linkForce)
  .force('charge', charge)
  //.force('center', d3.forceCenter(width / 2, height / 2))

if (!testSolve) {
	var dragDrop = d3.drag().on('start', function (node) {
	  node.fx = node.x
	  node.fy = node.y
	}).on('drag', function (node) {
	  simulation.alphaTarget(0.7).restart()
	  node.fx = d3.event.x
	  node.fy = d3.event.y
	}).on('end', function (node) {
	  if (!d3.event.active) {
		simulation.alphaTarget(0)
	  }
	  node.fx = null
	  node.fy = null
	})
} else {
	var dragDrop = function() {}
}

// select node is called on every click
// we either update the data according to the selection
// or reset the data if the same node is clicked twice
function selectNode(selectedNode) {
  /*if (selectedId === selectedNode.id) {
    selectedId = undefined
    resetData()
    updateSimulation()
  } else
  */
  {
    selectedId = selectedNode.id
    //updateData(selectedNode)
    updateSimulation()
  }

  var neighbors = getNeighbors(selectedNode)

  // we modify the styles to highlight selected nodes
  /*
  nodeElements.attr('fill', function (node) { return getNodeColor(node, neighbors) })
  textElements.attr('fill', function (node) { return getTextColor(node, neighbors) })
  linkElements.attr('stroke', function (link) { return getLinkColor(selectedNode, link) })
	*/
}

// this helper simple adds all nodes and links
// that are missing, to recreate the initial state
function resetData() {
  var nodeIds = nodes.map(function (node) { return node.id })

  baseNodes.forEach(function (node) {
    if (nodeIds.indexOf(node.id) === -1) {
      nodes.push(node)
    }
  })

  links = baseLinks
}

// diffing and mutating the data
/*function updateData(selectedNode) {
  var neighbors = getNeighbors(selectedNode)
  var newNodes = baseNodes.filter(function (node) {
    return neighbors.indexOf(node.id) > -1 || node.level === 1
  })

  var diff = {
    removed: nodes.filter(function (node) { return newNodes.indexOf(node) === -1 }),
    added: newNodes.filter(function (node) { return nodes.indexOf(node) === -1 })
  }

  diff.removed.forEach(function (node) { nodes.splice(nodes.indexOf(node), 1) })
  diff.added.forEach(function (node) { nodes.push(node) })

  links = baseLinks.filter(function (link) {
    return link.target.id === selectedNode.id || link.source.id === selectedNode.id
  })
}*/

function processGuess(guess) {
  if (guess == "你的名字") {
	guess = "你的名字。"
  }
  links = baseLinks.filter(function(link) {
    if (typeof link.source !== "object")
	  return visibleNodes.has(link.target) || visibleNodes.has(link.source)
	else
	  return visibleNodes.has(link.target.id) || visibleNodes.has(link.source.id)
  })
  showNodes = new Set()
  links.forEach(function(link) {
    if (typeof link.source !== "object") {
	  showNodes.add(link.source);
	  showNodes.add(link.target);
	} else {
	  showNodes.add(link.source.id);
	  showNodes.add(link.target.id);
	}
  });
  if (showNodes.has(guess)) {
	const beforeSize = visibleNodes.size;
	visibleNodes.add(guess)
	//document.getElementById("visible").innerHTML = visibleNodes.size;
	//document.getElementById("total").innerHTML = baseNodeSet.size;
	expandVisibleNodes()
	if (visibleNodes.size !== beforeSize) {
	  saveProgress()
	}
    updateSimulation()
  }
}

function updateData() {
  links = baseLinks.filter(function(link) {
    if (typeof link.source !== "object") {
	  return visibleNodes.has(link.target) || visibleNodes.has(link.source)
	}
	else {
	  return visibleNodes.has(link.target.id) || visibleNodes.has(link.source.id)
	}
  })
  showNodes = new Set()
  links.forEach(function(link) {
    if (typeof link.source !== "object") {
	  showNodes.add(link.source);
	  showNodes.add(link.target);
	} else {
	  showNodes.add(link.source.id);
	  showNodes.add(link.target.id);
	}
  });
  nodes = baseNodes.filter(function (node) {
	return showNodes.has(node.id)
  })

}

function updateGraph() {
  // links
  linkElements = linkGroup.selectAll('line')
    .data(links, function (link) {
      return link.target.id + link.source.id
    }).attr('stroke', function (link) {
		if (link.source.id == selectedId || link.target.id == selectedId) {
			return 'rgba(255, 0, 0, 0.8)'
		}
		return link.type == "extraction" ? 'rgba(255, 0, 0, 0.8)' : 'rgba(50, 50, 50, 0.2)'
	})

  linkElements.exit().remove()

  var linkEnter = linkElements
    .enter().append('line')
    .attr('stroke-width', 1)
    //.attr('stroke', 'rgba(50, 50, 50, 0.2)')
    .attr('stroke', function (link) {
		return link.type == "extraction" ? 'rgba(255, 0, 0, 0.8)' : 'rgba(50, 50, 50, 0.2)'
	})

  linkElements = linkEnter.merge(linkElements)

  // nodes
  nodeElements = nodeGroup.selectAll('circle')
    .data(nodes, function (node) { return node.id })

  nodeElements.exit().remove()

  var nodeEnter = nodeElements
    .enter()
    .append('circle')
    .attr('r', 3)
    .attr('fill', function (node) { return 'black' })
    .call(dragDrop)
    // we link the selectNode method here
    // to update the graph on every click
    .on('click', selectNode)

  nodeElements = nodeEnter.merge(nodeElements)

  // texts
  textElements = textGroup.selectAll('text')
    .data(nodes, function (node) {
	  return node.id
	})
	.text(function (node) {
	  if (forceShowDecomp)
	    return decomposeString(node.id)
	  else if (showDecomp)
		return visibleNodes.has(node.id) ? node.id : decomposeString(node.id)
	  else
		return node.id;
	})
	.attr('fill', function (node) { return getTextColor(node) })

  textElements.exit().remove()

  var textEnter = textElements
    .enter()
    .append('text')
    .text(function (node) {
		if (forceShowDecomp)
	      return decomposeString(node.id)
	    else if (showDecomp)
		  return visibleNodes.has(node.id) ? node.id : decomposeString(node.id)
		 else
		  return node.id;
	})
    .attr('font-size', 14)
    .attr('fill', function (node) { return getTextColor(node) })
    .attr('dx', 15)
    .attr('dy', 4)

  textElements = textEnter.merge(textElements)
}

function updateSimulation() {
  updateData()
  updateGraph()

  simulation.nodes(nodes).on('tick', () => {
    nodeElements
      .attr('cx', function (node) { return node.x })
      .attr('cy', function (node) { return node.y })
    textElements
      .attr('x', function (node) { return node.x })
      .attr('y', function (node) { return node.y })
    linkElements
      .attr('x1', function (link) { return link.source.x })
      .attr('y1', function (link) { return link.source.y })
      .attr('x2', function (link) { return link.target.x })
      .attr('y2', function (link) { return link.target.y })
  })

  simulation.force('link').links(links)
  if (handAdjust || testSolve)
	simulation.alphaMin(1.0)
  else
	simulation.alphaMin(0.75)
  simulation.alphaTarget(0.7).restart()

  /*
  simulation.on("end", () => {
    const xExtent = d3.extent(nodes, d => d.x);
    const yExtent = d3.extent(nodes, d => d.y);
    const newWidth = Math.abs(xExtent[0] - xExtent[1]);
    const newHeight = Math.abs(yExtent[0] - yExtent[1]);
	svg.attr("viewBox", [xExtent[0] - newWidth/20, yExtent[0]-newHeight/20, newWidth*1.1, newHeight*1.1]);
  })*/
}

// last but not least, we call updateSimulation
// to trigger the initial render
updateSimulation()

</script>

<body>
<div style="top:200px;left: 20px;position:fixed">
<h1>浮想联翩</h1>
<!-- <p><span id="visible"></span> / <span id="total"></span></p> -->
<!-- <p><input type="checkbox" id="startRandom" name="startRandom" checked> -->
<!-- <label for="startRandom">Start random (uncheck to show all)</label></p> -->
<!-- <p><input type="checkbox" id="showDecomp" name="showDecomp" checked>
<label for="showDecomp">Show IDS</label></p>
<p><input type="checkbox" id="showAllDecomp" name="showAllDecomp">
<label for="showAllDecomp">Show ALL IDS</label></p> -->
<p><input id="myInput" value=""></p>

<p>Note for this (temporary) archive version:
<ul>
<li>This note is not part of the puzzle.</li>
<li>Scroll down to see the start.</li>
<li>During the hunt, "username" shows the player's username.</li>
<li>Reading the source code is not part of the puzzle.</li>
<li>Progress auto-saves locally in your browser.</li>
<li>Answer checker: <a href="https://philippica.github.io/cipher_machine/check?answer=506e1c38a9d3f59b&problem=5rWu5oOz6IGU57%2Bp&endText=" target="_blank">Link</a></li>
<li>Solution: <a href="sol.html" target="_blank">Link</a></li>
</ul>
</p>
</div>
<script>
/*
var sd = document.getElementById("showDecomp");
sd.addEventListener('change', (event) => {
  showDecomp = event.target.checked;
  updateSimulation()
});

var sad = document.getElementById("showAllDecomp");
sad.addEventListener('change', (event) => {
  forceShowDecomp = event.target.checked;
  updateSimulation()
});
*/
/*var sr = document.getElementById("startRandom");
sr.addEventListener('change', (event) => {
  randomStart = event.target.checked;
  resetVisibleNodes()
  updateSimulation()
});*/

var input = document.getElementById("myInput");
input.addEventListener("keypress", function(event) {
  if (event.key === "Enter") {
    event.preventDefault();
    //.click();
	processGuess(document.getElementById("myInput").value);
	document.getElementById("myInput").value = "";
  }
});
</script>
</body>
